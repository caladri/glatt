Urgent:

Rewrite exception and TLB code.  Don't frob status unless we're task switching
out of an exception, as we really want happy-fun ERL and EXL so we don't have to
manually prevent exception nesting.  Also need to rework how TLBHI is used in
entirety.

I clearly missed something basic along the way.  Accesses to NULL are hitting my
0xc....0000 mapping!  It's like it's checking KSU to determine which address
space to look in, but I didn't think that's how it was supposed to work!  I am
going to rewrite as much of the TLB code as I can and make sure I'm actually
setting up mappings correctly (maybe fire up an IRIX box and look at what's in
the TLB), and make sure that I can trap on NULL access.  Maybe go over what
GXemul does and what Linux does, too.

Ad infinitum: Keep going over code and restructuring to make less ugly and
hokey and hard to maintain.

Make sure that all STAILQs and TAILQs and the like have their HEADs initialized properly.

o) VM.
	o) Better physical page data structures.
	o) Virtual page data structures.
	o) Cleanup pmap and friends.
	o) Locking.
	o) IPC.
	o) Userland.
	o) Allocate multiple contiguous physical pages.
o) Exceptions.
	o) Be careful to make correct use of EXL and ERL.  Without it, I am
	   leaving open a race where I can take an interrupt at 'eret' and then
	   when the exception pc is trashed, that eret will return to itself ad
	   absurdum.
	o) I think I'd like to rewrite it all with EXL and ERL in mind.  Might
	   be nice to wire the kernel stack, mark it dirty on insert, and start
	   using that as a place to store random crap.  Or use $gp as an
	   exception frame thing?
o) Tasks.
	o) Task switching.
		o) Better status register management.  Use the kernel one with
		   modifications to set the userland status.  Keep the kernel
		   one in the PCPU data and switch to it whenever switching to
		   a kernel task.  Status is not a thread state.  Cannot have a
		   task with userland and kernel threads, or 32 and 64-bit
		   threads.  That's just silly.
			o) Have some way of tracking when exceptions came from
			   user threads so that we can restore the correct
			   status, or make the thread contain a partial status
			   register.  Saving and restoring a status register
			   based on what's written to it *sucks*.
			   Probably nothing should directly touch the status
			   register.
		o) Userland.
	o) Threads.
		o) Userland.
	o) Userland.
o) Clocks.
	o) Scheduling.
o) Locking.
o) IPC.
	o) Userland.
o) Device drivers.
	o) Ethernet.
		o) IP.
			o) Arp.
			o) Multicast.
				o) IPC.
			o) IPC.
			o) Userland.
		o) IPC.
	o) Clock calibration.
