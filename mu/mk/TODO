Urgent:

Rewrite exception and TLB code.  Don't frob status unless we're task switching
out of an exception, as we really want happy-fun ERL and EXL so we don't have to
manually prevent exception nesting.

Ad infinitum: Keep going over code and restructuring to make less ugly and
hokey and hard to maintain.

Make sure that all STAILQs and TAILQs and the like have their HEADs initialized properly.

o) VM.
	o) Better physical page data structures.
	o) Virtual page data structures.
	o) Cleanup pmap and friends.
	o) Locking.
	o) IPC.
	o) Userland.
	o) Allocate multiple contiguous physical pages.
o) Exceptions.
	o) Be careful to make correct use of EXL and ERL.  Without it, I am
	   leaving open a race where I can take an interrupt at 'eret' and then
	   when the exception pc is trashed, that eret will return to itself ad
	   absurdum.
	o) I think I'd like to rewrite it all with EXL and ERL in mind.  Might
	   be nice to wire the kernel stack, mark it dirty on insert, and start
	   using that as a place to store random crap.  Or use $gp as an
	   exception frame thing?
o) Tasks.
	o) Task switching.
		o) Better status register management.  Use the kernel one with
		   modifications to set the userland status.  Keep the kernel
		   one in the PCPU data and switch to it whenever switching to
		   a kernel task.  Status is not a thread state.  Cannot have a
		   task with userland and kernel threads, or 32 and 64-bit
		   threads.  That's just silly.
			o) Have some way of tracking when exceptions came from
			   user threads so that we can restore the correct
			   status, or make the thread contain a partial status
			   register.  Saving and restoring a status register
			   based on what's written to it *sucks*.
			   Probably nothing should directly touch the status
			   register.
		o) Userland.
	o) Threads.
		o) Userland.
	o) Userland.
o) Clocks.
	o) Scheduling.
o) Locking.
o) IPC.
	o) Userland.
	o) CRUX system for renaming ports in a task.  For example mapping the
	   system port to a user port for emulation.  Such as:
	   	crux(IPC_PORT_SYSTEM, 1024);
		ipc_port_listen(1024);
		fd = open(name);
		ipc_port_receive(1024);
		/* fake open */
		crux_teardown(IPC_PORT_SYSTEM);
		/* real open */
o) Device drivers.
	o) Ethernet.
		o) IP.
			o) Arp.
			o) Multicast.
				o) IPC.
			o) IPC.
			o) Userland.
		o) IPC.
	o) Clock calibration.
