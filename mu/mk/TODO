Urgent:

I clearly missed something basic along the way.  Accesses to NULL are hitting my
0xc....0000 mapping!  It's like it's checking KSU to determine which address
space to look in, but I didn't think that's how it was supposed to work!  I am
going to rewrite as much of the TLB code as I can and make sure I'm actually
setting up mappings correctly (maybe fire up an IRIX box and look at what's in
the TLB), and make sure that I can trap on NULL access.  Maybe go over what
GXemul does and what Linux does, too.

Ad infinitum: Keep going over code and restructuring to make less ugly and
hokey and hard to maintain.

Make sure that all STAILQs and TAILQs and the like have their HEADs initialized properly.

o) VM.
	o) Better physical page data structures.
	o) Virtual page data structures.
	o) Cleanup pmap and friends.
	o) Locking.
	o) IPC.
	o) Userland.
	o) Allocate multiple contiguous physical pages.
o) Exceptions.
	o) Prevent nesting/corruption of the frame.
		o) Make everything use KERNEL_STATUS on exception entry.
o) Tasks.
	o) Task switching.
		o) Better status register management.  Use the kernel one with
		   modifications to set the userland status.  Keep the kernel
		   one in the PCPU data and switch to it whenever switching to
		   a kernel task.  Status is not a thread state.  Cannot have a
		   task with userland and kernel threads, or 32 and 64-bit
		   threads.  That's just silly.
			o) Have some way of tracking when exceptions came from
			   user threads so that we can restore the correct
			   status, or make the thread contain a partial status
			   register.  Saving and restoring a status register
			   based on what's written to it *sucks*.
			   Probably nothing should directly touch the status
			   register.
		o) Userland.
	o) Threads.
		o) Userland.
	o) Userland.
o) Clocks.
	o) Scheduling.
o) Locking.
o) IPC.
	o) Userland.
o) Device drivers.
	o) Ethernet.
		o) IP.
			o) Arp.
			o) Multicast.
				o) IPC.
			o) IPC.
			o) Userland.
		o) IPC.
	o) Clock calibration.
